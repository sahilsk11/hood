package trade_intelligence

import (
	"context"
	"hood/internal/domain"
	"sort"

	"github.com/shopspring/decimal"
)

type TLHRecomendation struct {
	Symbol               string          `json:"symbol"`
	SellQuantity         decimal.Decimal `json:"sellQuantity"`
	Loss                 decimal.Decimal `json:"loss"`
	BreakevenPriceChange decimal.Decimal `json:"breakevenPriceChange"`
}

/**
* minRequiredLoss: positive integer indicating how much
* loss must be generated by the sell to be considered
* i.e. selling must generate $1.50 in loss ($1 saved)
*
* minBreakevenPriceChange: min breakeven price percent change
* required to consider a lot for TLH
* i.e. if the asset needs to go up by only 1% to "break even"
* and be better to hold, we wouldn't want to sell. 5-10%
* seems more reasonable, especially for volatile assets
* 0 implies high risk - you only think it's going to go down
 */
func IdentifyTLHOptions(ctx context.Context, minRequiredLoss, minBreakevenPriceChange decimal.Decimal, lots []domain.OpenLot, prices map[string]decimal.Decimal) ([]TLHRecomendation, error) {
	tlhRecs := []TLHRecomendation{}
	lotsByTicker := map[string][]domain.OpenLot{}
	for _, lot := range lots {
		ticker := lot.Symbol
		if _, ok := lotsByTicker[ticker]; !ok {
			lotsByTicker[ticker] = []domain.OpenLot{}
		}
		lotsByTicker[ticker] = append(lotsByTicker[ticker], lot)
	}

	for ticker := range lotsByTicker {
		sortedLots := lotsByTicker[ticker]
		sort.Slice(sortedLots, func(i, j int) bool {
			return sortedLots[i].PurchaseDate.Unix() < sortedLots[j].PurchaseDate.Unix()
		})
		// use gain because the value (loss) will be negative
		price := prices[ticker]
		minGain, minGainQuantity := calculateMaxLossGivenPriceRisk(sortedLots, price, minBreakevenPriceChange)
		maxLoss := minGain.Neg()

		// if we can produce a loss greater than threshold
		if maxLoss.GreaterThan(minRequiredLoss) {
			breakevenPriceChange := calculateTlhPriceRisk(minGain, minGainQuantity, price)
			tlhRecs = append(tlhRecs, TLHRecomendation{
				Symbol:               ticker,
				SellQuantity:         minGainQuantity,
				Loss:                 minGain.Neg(),
				BreakevenPriceChange: breakevenPriceChange,
			})
		}
	}

	return tlhRecs, nil
}

// use 0 for tlhPriceRisk to simply maximize loss
func calculateMaxLossGivenPriceRisk(sortedLots []domain.OpenLot, price, tlhPriceRisk decimal.Decimal) (decimal.Decimal, decimal.Decimal) {
	minGain := decimal.Zero
	minGainQuantity := decimal.Zero

	currentGain := decimal.Zero
	currentQuantity := decimal.Zero
	for _, lot := range sortedLots {
		unrealizedGain := price.Sub(lot.CostBasis).Mul(lot.Quantity)
		currentGain = currentGain.Add(unrealizedGain)
		currentQuantity = currentQuantity.Add(lot.Quantity)
		breakevenPriceChangePercent := calculateTlhPriceRisk(currentGain, currentQuantity, price)
		if currentGain.LessThan(minGain) && breakevenPriceChangePercent.GreaterThan(tlhPriceRisk) {
			minGain = currentGain
			minGainQuantity = currentQuantity
		}
	}

	return minGain, minGainQuantity
}

func calculateTlhPriceRisk(minGain, quantity, assetPrice decimal.Decimal) decimal.Decimal {
	ltTaxRate := decimal.NewFromFloat(0.15)

	moneySaved := minGain.Neg().Mul(ltTaxRate)
	// to make that same amount of money,
	// the value of assets sold needs to go
	// up by the same amount AFTER tax
	// 0.85x = moneySaved; x needed to break even
	breakEvenAmount := moneySaved.Div(decimal.NewFromInt(1).Sub(ltTaxRate))
	increasePerUnit := breakEvenAmount.Div(quantity)

	percentChangePerUnit := (increasePerUnit.Div(assetPrice)).Mul(decimal.NewFromInt(100))

	return percentChangePerUnit
}
